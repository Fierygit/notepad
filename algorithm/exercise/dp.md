---
title: DP
date: 2019-12-28
categories: ["算法"]
tags: ["DP"]
---
# <center> DP 题目汇总 </center>

记录一些遇到过的dp问题



DP(Dynamic Programming) 一种解决最优化问题的算法思想。

要求： **重叠子问题** && **最优子结构**



- 递归： 记忆化搜索

- 递推： 自底向上





[toc]

#### 比特位计数

> 给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。









#### 最大连续子序和

```c
dp[i] = max{A[i], dp[i-1] + A[i]}
```



#### 最长不下降子序列

```c
dp[i] = max{1, dp[j] + 1}  (贪心也可以)
```



#### 最长公共子序列（LCS）

```c
dp[i][j] = dp[i-1][j-1] + 1, A[i] == B[j]
    		max{dp[i-1][j], dp[i][j-1], A[i] != B[j]}
```



#### 最长回文子串

```c
dp[i][j] = dp[i+1][j-1], S[i] == S[j]
    		0, S[i] != S[j]
```



#### 01 背包问题

```c
d[i][v] = max{dp[i-1][v], dp[i-1][v-w[i]] + c[i]}
```



#### 完全背包问题

```c
dp[i][v] = max{dp[i-1], dp[i][v - w[i]] + c[i]}
```



#### 非相连最大和

```c
sum(k) = max(sum(k – 2) + A[k], sum(k – 1))
```



#### leetcode - dp中等专题

##### 60.不同的二叉搜索树

> 一组数据能够构成二叉树的最多的装填类型

*F*(*i*,*n*)=*G*(*i*−1)⋅*G*(*n*−*i*)

把一组数据看成左右和中间一点



##### 198.打家劫舍

> 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

dp[i + 2] = max(dp[i] + nums[i], dp[i+1]);

对于一家要么偷（取前两个之前最大的和加上前两个）， 要么不偷（取前面一个的就行了）



##### 740. 删除与获得点数

> 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

nums = [2, 2, 3, 3, 3, 4]	变换一下	all=[0, 0, 2, 3, 1];

dp[i + 2] = max(dp[i] + i * nums[i], dp[i+1]);

和打家劫舍一样



##### 面试题 08.11. 硬币

> 给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。

```c
for (int c = 0; c < 4; ++c) {
    int coin = coins[c];
    for (int i = coin; i <= n; ++i) 
        f[i] = (f[i] + f[i - coin]) % mod;
}
```

##### 464. 我能赢吗

> 在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

使用 dfs +  状态记忆就可以了, 太巧秒了

```c
void dfs(int cur){
	if(满足条件) return true;
	for(int i = 0; i < n; i++){
		if(!visited[i]) continue;
		if(dfs(cur + i)){// 注意这里是输的，状态反过来了
			return false;
		}
	}
    return false;
}
```



##### 523. 连续的子数组和

> 给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

1、 使用前缀和的方法，将 O（n^3） 优化为 O（n^ 2）

2、 很巧妙，记录所有前缀和的取余的数据

j --  i 如果是满足答案的， 那么， 前缀和 map[j % k] == map[i % k], 可以证明得到



##### 375. 猜数字大小 II

> 我们正在玩一个猜数游戏，游戏规则如下：我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。



##### 718. 最长重复子数组

>  给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

dp [i] [j] 表示A 从 i 和  B 从 j的最长的前缀和



##### 376. 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

摆动序列和一个数组的最大乘积和是一样的， 要记录两个状态！！！





##### 剑指 Offer 14- II. 剪绳子 II

> 给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

这道题是一道数学题， 只要一直往3 减去就好了。



##### 983. 最低票价

> 难度中等237收藏分享切换为英文关注反馈

> 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。

> 火车票有三种不同的销售方式：

- 一张为期一天的通行证售价为 `costs[0]` 美元；
- 一张为期七天的通行证售价为 `costs[1]` 美元；
- 一张为期三十天的通行证售价为 `costs[2]` 美元。

> 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费。

我们用 dp*(*i*) 来表示从第  i  天开始到一年的结束，我们需要花的钱。



##### 221. 最大正方形

> 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

dp[i] [j] 表示在i, j 点的最大大正方形

dp 转移方程只要去左边，左上和上边最小的就可以了



##### 面试题 01.05. 一次编辑

> 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

dp[i] [j] 表示 第一个字符在 i， 第二个字符在 j 的时候编辑次数, 模拟出删除，替换，和拆入



##### 376. 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

和整数和一样，使用两个记录状态和， 也可以直接贪心， 因为前面的跟后面的没有关系，前面一个是上升的就接着找下一个下降的就行



##### 718. 最长重复子数组

> 给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

二维dp



##### 面试题 08.02. 迷路的机器人

> 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

可以使用 dfs 加上减枝， 也可以使用dfs，相当于 bfs



##### 面试题 17.06. 2出现的次数

> 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。

遍历每一位数字， 计算每一位数字大于2， 等于 2， 小于 2 的情况！

```c
int numberOf2sInRange(int n) {
    long base = 1, total = 0;
    int pre = n/(10);
    int exatnum = n%10;
    int post = 0;
    while(n != post){
        if(exatnum>2){
            total += (pre+1)*base;
        } else if(exatnum==2){
            total += pre*base + post+1;
        } else {
            total += pre*base;
        }
        post += exatnum*base;
        exatnum = pre%10;
        pre /= 10;
        base *= 10;
    }
    return total;
}
```





##### 1367. 二叉树中的列表

> 给你一棵以 `root` 为根的二叉树和一个 `head` 为第一个节点的链表。
>
> 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 `head` 为首的链表中每个节点的值，那么请你返回 `True` ，否则返回 `False` 。
>
> 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

暴力， 没有什么难度



##### 95. 不同的二叉搜索树 II

>  给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树** 。

太巧妙了！！！， 递归的优雅之处！！！， **看到停下来，** **再看一遍**

```c
vector<TreeNode*> helper(int start, int end) {
    if(start > end) return {nullptr};
    vector<TreeNode*> res;
    for(int i=start; i<=end; i++) {
        auto left = helper(start, i-1), right = helper(i+1, end);
        for(auto a:left) {
            for(auto b:right) {
                TreeNode* node = new TreeNode(i);
                node->left = a;
                node->right = b;
                res.push_back(node);
            }
        }
    }
    return res;
}
```





##### 1372. 二叉树中的最长交错路径

> 给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

```c
class Solution {
public:
    int maxAns;
    /* 0 => left, 1 => right */
    void dfs(TreeNode* o, bool dir, int len) {
        maxAns = max(maxAns, len);
        if (!dir) {
            if (o->left) dfs(o->left, 1, len + 1);
            if (o->right) dfs(o->right, 0, 1);
        } else {
            if (o->right) dfs(o->right, 0, len + 1);
            if (o->left) dfs(o->left, 1, 1);
        }
    } 

    int longestZigZag(TreeNode* root) {
        if (!root) return 0;
        maxAns = 0;
        dfs(root, 0, 0); dfs(root, 1, 0);
        return maxAns;
    }
};
```



##### 213. 打家劫舍 II

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

分位两种情况来计算dp！



##### 279. 完全平方数

> 给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

二维dp



##### 5. 最长回文子串

>  给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

dp[i] [j] 表示 从 i 到 j 是一个回文子串



##### 面试题 17.08. 马戏团人塔

有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。

```c
class Solution {
    using vint = vector<int>;
public:
    int bestSeqAtIndex(vector<int>& height, vector<int>& weight) {
        int len = height.size();
        vector<vint> k(len,vint(2,0));
        for(int i = 0; i < len; ++i) k[i][0] = height[i], k[i][1] = weight[i];        
        sort(k.begin(),k.end(),[](const vint& a,const vint& b){
            if(a[0] != b[0]) return a[0] < b[0];
            else return a[1] > b[1];
        });
        vint m(1,0);
        for(int i = 0; i < len; ++i){
            auto p = lower_bound(m.begin(),m.end(),k[i][1])-m.begin();
            if(p == m.size()) m.push_back(k[i][1]);
            else m[p] = k[i][1];
        }
        return m.size()-1;
    }
};
```



##### 516. 最长回文子序列

> 给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

二维dp



##### 1143. 最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

二维dp



##### 801. 使序列递增的最小交换次数

> 我们有两个长度相等且不为空的整型数组 `A` 和 `B` 。
>
> 我们可以交换 `A[i]` 和 `B[i]` 的元素。注意这两个元素在各自的序列中应该处于相同的位置。
>
> 在交换过一些元素之后，数组 `A` 和 `B` 都应该是严格递增的（数组严格递增的条件仅为`A[0] < A[1] < A[2] < ... < A[A.length - 1]`）。
>
> 给定数组 `A` 和 `B` ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，
没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，



##### 1314. 矩阵区域和

> 给你一个 `m * n` 的矩阵 `mat` 和一个整数 `K` ，请你返回一个矩阵 `answer` ，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和： 

- `i - K <= r <= i + K, j - K <= c <= j + K` 
- `(r, c)` 在矩阵内。

使用前缀和记录每一个小矩阵的值， easy



##### 931. 下降路径最小和

> 给定一个**方形**整数数组 `A`，我们想要得到通过 `A` 的*下降路径*的**最小**和。
>
> 下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。

easy dp[i] [j] 表示为 在 i， j 位置的最小和



#####  剑指 Offer 63. 股票的最大利润

> 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

贪心， 只需要记住之前最小的股票价格就好了



##### 1339. 分裂二叉树的最大乘积

> 给你一棵二叉树，它的根为 `root` 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

```c
int maxProduct(TreeNode* root) {
    postOrder(root);
    long res = -1;
    for (int i = 0; i < sums.size() - 1; ++i) {
        // 取最大值时不能取模，应该用long型存结果
        res = max(res, sums[i] * (sums.back() - sums[i]));
    }
    return (int)(res % mod);
}

long postOrder(TreeNode* root) {
    if (root == nullptr) return 0;
    long res = root->val + postOrder(root->left) + postOrder(root->right);
    sums.push_back(res);
    return res;
}
```

太巧妙了， 后序遍历的做法， 太太太太太太太太太太太太巧妙了！！！*****************************************



##### 435. 无重叠区间

> 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
>
>**注意:**
>
> 1. 可以认为区间的终点总是大于它的起点。
> 2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

求最长上升子序列, 模版题记住！！！

```c
class Solution {
    using vint = vector<int>;
    using vvint = vector<vint>;
public:
    int eraseOverlapIntervals(vvint& intervals) {
        if(!intervals.size()) return 0;
        sort(intervals.begin(), intervals.end(),[](const vint& a, const vint& b){
            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);
        });
        int ans = 0, end = intervals[0][1];
        for(const auto& i : intervals){
            cout << i[0] << " " << i[1] << endl;
            if(i[0] < end){
                if(i[1] < end) end = i[1];
                ans++;
            }  
            else   end = i[1];
        }
        return ans - 1;
    }
};
```



##### 646. 最长数对链

> 给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
>
> 现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。
>
> 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

和上题基本一样， 模版题来的！！！



##### 1477. 找两个和为目标值且不重叠的子数组

>给你一个整数数组 `arr` 和一个整数值 `target` 。
>
>请你在 `arr` 中找 **两个互不重叠的子数组** 且它们的和都等于 `target` 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 **最小值** 。
>
>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 **-1** 。

```c
 int minSumOfLengths(vector<int>& arr, int target) {
     int sum = 0, r = arr.size() - 1, ans = 200000; 
     vector<int> len(arr.size() + 1, 200000);
     for (int l = r; l >= 0; --l) { //l,r是滑动区间的左右坐标
         sum += arr[l];
         while (sum > target) sum -= arr[r--];
         if (sum == target) {
             int cur = r - l + 1; //子数组长度
             ans = min(ans, cur + len[r + 1]); //子数组长度 + 后面子数组的最小长度
             len[l] = min(len[l + 1], cur); //更新子数组的最小长度
         }
         else len[l] = len[l + 1]; //更新子数组的最小长度
     }
     return ans == 200000 ? -1 : ans;
 }
```

很巧妙，多看看， 使用滑动窗口解决问题





##### 650. 只有两个键的键盘

> 最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
>
>1. `Copy All` (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
>2. `Paste` (粘贴) : 你可以粘贴你**上一次**复制的字符。
>
>给定一个数字 `n` 。你需要使用最少的操作次数，在记事本中打印出**恰好** `n` 个 'A'。输出能够打印出 `n` 个 'A' 的最少操作次数。

steps[n] = steps[i] + n/i, 核心在于找到最大的因子， 这样可以尽可能的少操作数据



##### 712. 两个字符串的最小ASCII删除和

> 给定两个字符串`s1, s2`，找到使两个字符串相等所需删除字符的ASCII值的最小和。

聪明一点，这道题就是 LCS的扩展版！！！！！！！！！！！！！！！！！和 lcs 基本是一样的啊啊啊啊啊啊





##### 494. 目标和

> 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。
>
>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```java
public int findTargetSumWays(int[] nums, int S) {
    int[][] dp = new int[nums.length][2001];
    dp[0][nums[0] + 1000] = 1;
    dp[0][-nums[0] + 1000] += 1;
    for (int i = 1; i < nums.length; i++) {
        for (int sum = -1000; sum <= 1000; sum++) {
            if (dp[i - 1][sum + 1000] > 0) {
                dp[i][sum + nums[i] + 1000] += dp[i - 1][sum + 1000];
                dp[i][sum - nums[i] + 1000] += dp[i - 1][sum + 1000];
            }
        }
    }
    return S > 1000 ? 0 : dp[nums.length - 1][S + 1000];
}
```

背包问题的修改， 强！ 要点在于加上了 1000， 处理负数的情况



##### 1155. 掷骰子的N种方法
>这里有 `d` 个一样的骰子，每个骰子上都有 `f` 个面，分别标号为 `1, 2, ..., f`。
>
>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。
>
>如果需要掷出的总点数为 `target`，请你计算出有多少种不同的组合情况（所有的组合情况总共有 `f^d` 种），**模 `10^9 + 7`** 后返回。

dp[i] [j] 表示前i 个筛子， 得分为j的情况

```c
int numRollsToTarget(int d, int f, int target) {
    const int mod = 1e9+7;
    vector<vector<int>> dp(d + 1, vector<int>(target + 1, 0));
    dp[0][0] = 1;
    for(int i = 1; i <= d; i ++){
        for(int j = i; j <= target; j ++){
            for(int k = 1; k <= f && j - k >= 0; k ++){// 对于每一种的取分，
                dp[i][j] += dp[i-1][j-k];
                dp[i][j] %= mod;
            }
        }
    }
    return  dp[d][target];
}
```

比较难的 3 维dp 问题。



##### 1277. 统计全为 1 的正方形子矩阵

> 给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。

和中间是正方形的做法是一样的！

dp[i] [j] 表示到 i ，j 时是否为正方形



